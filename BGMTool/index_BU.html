<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunny Retro Studio</title>
    
    <!-- Google Fonts: Press Start 2P (Logo) & Silkscreen (UI) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'gba-bg-dark': '#131824',
                        'gba-bg-med': '#20283d',
                        'gba-bg-light': '#323c52',
                        'gba-border': '#1e2536',
                        'gba-border-light': '#4a5570',
                        'gba-text': '#e0e7ff',
                        'gba-text-muted': '#8593b8',
                        'gba-green': '#69c456',
                        'gba-green-light': '#84d671',
                        'gba-red': '#e55c5c',
                        'gba-red-light': '#f77c7c',
                        'gba-yellow': '#f2d449',
                        'gba-yellow-light': '#ffe570',
                        'gba-blue': '#70d6ff',
                        'gba-purple': '#a881ff',
                        'gba-btn': '#3f4a63',
                        'gba-btn-hover': '#515e7d',
                    }
                }
            }
        }
    </script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Import Map for ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>

    <style>
        /* Base Retro Settings */
        body {
            font-family: 'Silkscreen', monospace;
            image-rendering: pixelated; /* Keeps icons sharp */
            font-size: 14px; /* Silkscreen is chunky, 14px is good */
            background-color: #20283d;
            color: #e0e7ff;
        }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
        }

        /* Custom Retro Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 14px;
            height: 14px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #20283d;
            border-left: 2px solid #1e2536;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #3f4a63;
            border: 2px solid #1e2536; /* Pseudo-pixel border */
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #515e7d;
        }
        .custom-scrollbar::-webkit-scrollbar-corner {
            background: #20283d;
        }
        
        /* Retro Button Classes (Utility) */
        .retro-btn {
            border-width: 2px;
            border-bottom-width: 4px;
            border-color: #1e2536; /* darker shade */
            transition: all 0.05s;
            text-transform: uppercase;
        }
        .retro-btn:active {
            border-bottom-width: 2px;
            transform: translateY(2px);
        }

        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body class="overflow-hidden selection:bg-gba-blue selection:text-gba-bg-dark">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Play, Pause, Trash2, Volume2, Save, Upload, Music, Wand2, AlertTriangle, ArrowRight, ArrowLeft, FileWarning, Plus, X, Settings2, Sliders, Dices, Download, ClipboardCopy, ClipboardPaste, FolderOpen, CheckCircle } from 'lucide-react';

        // --- FILE SYSTEM UTILS (TAURI SUPPORT) ---
        const isTauri = typeof window !== 'undefined' && window.__TAURI__ !== undefined;

        async function saveFileTauri(filename, content, ext) {
            if (!isTauri) return null;
            try {
                const { dialog, fs } = window.__TAURI__;
                
                // Determine filter name based on extension
                let filterName = 'Project';
                if (ext === 'wav') filterName = 'Audio';
                if (ext === 'mid') filterName = 'MIDI';

                const filePath = await dialog.save({
                    defaultPath: filename,
                    filters: [{
                        name: filterName,
                        extensions: [ext]
                    }]
                });

                if (!filePath) return null; 

                // Handle binary files (WAV or MIDI) vs Text files (JSON)
                if (ext === 'wav' || ext === 'mid') {
                    // Check if content is already a Uint8Array or ArrayBuffer, or Blob
                    let binaryData;
                    if (content instanceof Blob) {
                        const arrayBuffer = await content.arrayBuffer();
                        binaryData = new Uint8Array(arrayBuffer);
                    } else if (content instanceof Uint8Array) {
                        binaryData = content;
                    } else {
                        // Fallback/Error case
                        console.error("Invalid binary content format");
                        return null;
                    }
                    await fs.writeBinaryFile(filePath, binaryData);
                } else {
                    await fs.writeTextFile(filePath, content);
                }
                return filePath;
            } catch (e) {
                console.error("Tauri Save Error:", e);
                alert("Failed to save file via Tauri.");
                return null;
            }
        }

        async function openFileLocationTauri(filePath) {
            if (!isTauri || !filePath) return;
            try {
                const { shell } = window.__TAURI__;
                const separator = filePath.includes('\\') ? '\\' : '/';
                const directory = filePath.substring(0, filePath.lastIndexOf(separator));
                await shell.open(directory); 
            } catch (e) {
                console.error("Tauri Open Error:", e);
            }
        }

        // --- AUDIO ENGINE ---
        const NOTE_FREQS = {
            "C3": 130.81, "C#3": 138.59, "D3": 146.83, "D#3": 155.56, "E3": 164.81, "F3": 174.61, "F#3": 185.00, "G3": 196.00, "G#3": 207.65, "A3": 220.00, "A#3": 233.08, "B3": 246.94,
            "C4": 261.63, "C#4": 277.18, "D4": 293.66, "D#4": 311.13, "E4": 329.63, "F4": 349.23, "F#4": 369.99, "G4": 392.00, "G#4": 415.30, "A4": 440.00, "A#4": 466.16, "B4": 493.88,
            "C5": 523.25, "C#5": 554.37, "D5": 587.33, "D#5": 622.25, "E5": 659.25, "F5": 698.46, "F#5": 739.99, "G5": 783.99, "G#5": 830.61, "A5": 880.00, "A#5": 932.33, "B5": 987.77
        };

        const ORDERED_NOTES = Object.keys(NOTE_FREQS).reverse();

        class RetroSynth {
            constructor(audioContext) {
                this.ctx = audioContext || new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(this.ctx.destination);
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.connect(this.masterGain);
            }

            playTone(freq, type, time, duration, vol, params) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                const a = params?.attack || 0.01;
                const d = params?.decay || 0.1;
                const s = params?.sustain !== undefined ? params.sustain : 0.5;
                const r = params?.release || 0.2;
                const tone = params?.timbre !== undefined ? params.timbre : 1.0;

                osc.type = type;
                osc.frequency.setValueAtTime(freq, time);

                filter.type = 'lowpass';
                const cutoff = 200 + (tone * 9800); 
                filter.frequency.setValueAtTime(cutoff, time);

                const attackEnd = time + a;
                const decayEnd = attackEnd + d;
                const releaseStart = time + duration;
                const releaseEnd = releaseStart + r;

                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, attackEnd); 
                gain.gain.exponentialRampToValueAtTime(Math.max(0.001, vol * s), decayEnd); 
                gain.gain.setValueAtTime(Math.max(0.001, vol * s), releaseStart); 
                gain.gain.exponentialRampToValueAtTime(0.001, releaseEnd);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.compressor);

                osc.start(time);
                osc.stop(releaseEnd + 0.1); 
            }

            playNoise(time, duration, vol, params) {
                const bufferSize = this.ctx.sampleRate * (duration + (params?.release || 0.2));
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                const a = params?.attack || 0.01;
                const d = params?.decay || 0.1;
                const s = params?.sustain !== undefined ? params.sustain : 0.5;
                const r = params?.release || 0.2;
                const tone = params?.timbre !== undefined ? params.timbre : 0.5;

                if (tone < 0.5) {
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200 + (tone * 2000), time); 
                } else {
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(1000 + ((tone - 0.5) * 8000), time); 
                }

                const attackEnd = time + a;
                const decayEnd = attackEnd + d;
                const releaseStart = time + duration;
                const releaseEnd = releaseStart + r;

                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, attackEnd); 
                gain.gain.exponentialRampToValueAtTime(Math.max(0.001, vol * s), decayEnd); 
                gain.gain.setValueAtTime(Math.max(0.001, vol * s), releaseStart); 
                gain.gain.exponentialRampToValueAtTime(0.001, releaseEnd);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.compressor);
                noise.start(time);
            }

            playDrum(type, time, vol) {
                if (type === 'kick') {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                    gain.gain.setValueAtTime(vol, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    osc.connect(gain);
                    gain.connect(this.compressor);
                    osc.start(time);
                    osc.stop(time + 0.5);
                } else if (type === 'snare') {
                    this.playNoise(time, 0.2, vol * 0.8, {attack:0.001, decay:0.1, sustain:0, release:0.1, timbre: 0.3}); 
                    this.playTone(200, 'triangle', time, 0.1, vol * 0.5, {attack:0.001, decay:0.1, sustain:0, release:0.1, timbre: 1}); 
                } else if (type === 'hihat') {
                    this.playNoise(time, 0.05, vol * 0.6, {attack:0.001, decay:0.05, sustain:0, release:0.05, timbre: 0.9});
                }
            }

            resume() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }
        }

        // --- WAV EXPORT UTILS ---
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            setUint32(0x46464952);                         
            setUint32(length - 8);                         
            setUint32(0x45564157);                         
            setUint32(0x20746d66);                         
            setUint32(16);                                 
            setUint16(1);                                  
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); 
            setUint16(numOfChan * 2);                      
            setUint16(16);                                 
            setUint32(0x61746164);                         
            setUint32(length - pos - 4);                   

            for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

            while(pos < length) {
                for(i = 0; i < numOfChan; i++) {             
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); 
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; 
                    view.setInt16(pos, sample, true);          
                    pos += 2;
                }
                offset++                                     
            }
            return new Blob([buffer], {type: "audio/wav"});
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        }

        // --- MIDI ENCODER UTILS ---
        const MIDI_NOTE_MAP = {
            "C": 0, "C#": 1, "D": 2, "D#": 3, "E": 4, "F": 5, "F#": 6, "G": 7, "G#": 8, "A": 9, "A#": 10, "B": 11
        };

        class SimpleMidiWriter {
            constructor(bpm, trackName) {
                this.bpm = bpm;
                this.trackName = trackName;
                this.tracks = [];
            }

            addTrack(notes, isDrum, trackName) {
                const events = [];
                // Standard MIDI resolution (Ticks Per Quarter Note)
                const TPQ = 128; 
                // We are using 16th notes. 1 quarter = 4 16ths.
                // So 1 step (16th note) = 128 / 4 = 32 ticks.
                const TICKS_PER_STEP = 32;

                // 1. Convert Grid Notes to Linear MIDI Events
                Object.keys(notes).forEach(stepStr => {
                    const step = parseInt(stepStr);
                    const noteData = notes[step];
                    const durationTicks = (noteData.length || 1) * TICKS_PER_STEP;
                    const startTick = step * TICKS_PER_STEP;
                    
                    let midiNum;
                    if (isDrum) {
                        // General MIDI Drum Map
                        if (noteData.note === "Kick") midiNum = 36; // C1
                        else if (noteData.note === "Snare") midiNum = 38; // D1
                        else if (noteData.note === "HiHat") midiNum = 42; // F#1 (Closed HH)
                        else if (noteData.note === "Clap") midiNum = 39; // D#1
                        else midiNum = 36;
                    } else {
                        // Parse "C#4" -> Note: C#, Octave: 4
                        const match = noteData.note.match(/([A-G]#?)(\d)/);
                        if (match) {
                            const noteName = match[1];
                            const octave = parseInt(match[2]);
                            midiNum = (octave + 1) * 12 + MIDI_NOTE_MAP[noteName];
                        }
                    }

                    if (midiNum) {
                        // Note On
                        events.push({ type: 0x90, note: midiNum, velocity: 100, tick: startTick });
                        // Note Off
                        events.push({ type: 0x80, note: midiNum, velocity: 0, tick: startTick + durationTicks });
                    }
                });

                // 2. Sort events by time
                events.sort((a, b) => a.tick - b.tick);

                // 3. Generate Hex Data
                let trackData = [];
                
                // Track Name Meta Event
                trackData = trackData.concat(this.strToBytes(0xFF, 0x03, trackName));
                
                // Tempo Meta Event (Set Tempo)
                // Microseconds per quarter note = 60,000,000 / BPM
                const mpqn = Math.floor(60000000 / this.bpm);
                trackData.push(0x00, 0xFF, 0x51, 0x03, (mpqn >> 16) & 0xFF, (mpqn >> 8) & 0xFF, mpqn & 0xFF);

                let lastTick = 0;
                
                // Channel determination (Drums must be Ch 10, which is index 9)
                const channel = isDrum ? 9 : 0; 

                events.forEach(e => {
                    const delta = e.tick - lastTick;
                    const vlq = this.toVLQ(delta);
                    trackData = trackData.concat(vlq);
                    
                    // Status byte: Event Type | Channel
                    // Note On (0x90) or Note Off (0x80) | Channel
                    const status = e.type | channel;
                    trackData.push(status, e.note, e.velocity);
                    
                    lastTick = e.tick;
                });

                // End of Track Meta Event
                trackData.push(0x00, 0xFF, 0x2F, 0x00);

                this.tracks.push(trackData);
            }

            toVLQ(num) {
                let bytes = [];
                let temp = num;
                do {
                    let byte = temp & 0x7F;
                    temp = temp >> 7;
                    if (bytes.length > 0) byte = byte | 0x80;
                    bytes.unshift(byte);
                } while (temp > 0);
                return bytes;
            }

            strToBytes(type, subtype, str) {
                const charCodes = str.split('').map(c => c.charCodeAt(0));
                return [0x00, type, subtype, charCodes.length, ...charCodes];
            }

            build() {
                // Header Chunk
                // MThd + Length(6) + Format(1) + Tracks(count) + Division(128 ticks)
                const trackCount = this.tracks.length;
                const header = [
                    0x4D, 0x54, 0x68, 0x64, // MThd
                    0x00, 0x00, 0x00, 0x06, // Chunk Size
                    0x00, 0x01,             // Format 1 (Multi-track)
                    (trackCount >> 8) & 0xFF, trackCount & 0xFF, // Number of tracks
                    0x00, 0x80              // 128 Ticks Per Quarter Note
                ];

                let fileData = [...header];

                this.tracks.forEach(tData => {
                    // MTrk + Length + Data
                    const len = tData.length;
                    const trackHeader = [
                        0x4D, 0x54, 0x72, 0x6B, // MTrk
                        (len >> 24) & 0xFF, (len >> 16) & 0xFF, (len >> 8) & 0xFF, len & 0xFF
                    ];
                    fileData = fileData.concat(trackHeader, tData);
                });

                return new Uint8Array(fileData);
            }
        }

        // --- TEMPLATE DATA ---
        const PATTERN_TEMPLATES = {
            drum: [
                { name: "Basic Rock", notes: { 0: {note:"Kick", length:1}, 2: {note:"HiHat", length:1}, 4: {note:"Snare", length:1}, 6: {note:"HiHat", length:1}, 8: {note:"Kick", length:1}, 10: {note:"HiHat", length:1}, 12: {note:"Snare", length:1}, 14: {note:"HiHat", length:1} } },
                { name: "Four on Floor", notes: { 0: {note:"Kick", length:1}, 2: {note:"HiHat", length:1}, 4: {note:"Kick", length:1}, 6: {note:"HiHat", length:1}, 8: {note:"Kick", length:1}, 10: {note:"HiHat", length:1}, 12: {note:"Kick", length:1}, 14: {note:"HiHat", length:1}, 4: {note:"Clap", length:1}, 12: {note:"Clap", length:1} } }
            ],
            melody: [
                { name: "C Major Arp", notes: { 0: {note:"C4", length:1}, 2: {note:"E4", length:1}, 4: {note:"G4", length:1}, 6: {note:"C5", length:1}, 8: {note:"G4", length:1}, 10: {note:"E4", length:1}, 12: {note:"C4", length:2} } },
                { name: "Long Notes", notes: { 0: {note:"C4", length:4}, 4: {note:"G4", length:4}, 8: {note:"A4", length:4}, 12: {note:"F4", length:4} } }
            ],
            bass: [
                { name: "Driving Root", notes: { 0: {note:"C3", length:1}, 2: {note:"C3", length:1}, 4: {note:"C3", length:1}, 6: {note:"C3", length:1}, 8: {note:"C3", length:1}, 10: {note:"C3", length:1}, 12: {note:"C3", length:1}, 14: {note:"C3", length:1} } },
                { name: "Sustained Bass", notes: { 0: {note:"C3", length:4}, 4: {note:"E3", length:4}, 8: {note:"F3", length:4}, 12: {note:"G3", length:4} } }
            ]
        };

        // GBA Color Palette for Tracks
        const AVAILABLE_COLORS = [
            "bg-gba-blue", "bg-gba-purple", "bg-gba-green", "bg-gba-red", 
            "bg-gba-yellow", "bg-[#ff9f43]", "bg-[#ff6b6b]", "bg-[#54a0ff]",
            "bg-[#7bed9f]", "bg-[#2ed573]"
        ];
        const DRUM_MAP = ["Kick", "Snare", "HiHat", "Clap"];
        const STEPS_PER_BAR = 16;

        const getDefaultParams = () => ({ attack: 0.02, decay: 0.1, sustain: 0.6, release: 0.2, timbre: 1.0 });

        const INITIAL_TRACKS = [
            { id: 1, name: "Lead 1 (Square)", type: "square", volume: 0.6, color: "bg-gba-blue", notes: {}, params: getDefaultParams() },
            { id: 2, name: "Lead 2 (Saw)", type: "sawtooth", volume: 0.5, color: "bg-gba-purple", notes: {}, params: { ...getDefaultParams(), timbre: 0.8, attack: 0.05 } },
            { id: 3, name: "Bass (Tri)", type: "triangle", volume: 0.7, color: "bg-gba-green", notes: {}, params: { ...getDefaultParams(), timbre: 0.6, decay: 0.3, sustain: 0.8 } },
            { id: 4, name: "Drums", type: "drum", volume: 0.8, color: "bg-gba-red", notes: {}, params: getDefaultParams() }, 
        ];

        function RetroMusicCreator() {
            const [tracks, setTracks] = useState(INITIAL_TRACKS);
            const [selectedTrackId, setSelectedTrackId] = useState(1);
            const [bpm, setBpm] = useState(120);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [showTemplates, setShowTemplates] = useState(false);
            const [isExporting, setIsExporting] = useState(false);
            
            const [clearConfirmType, setClearConfirmType] = useState(null);
            const [isAddTrackOpen, setIsAddTrackOpen] = useState(false);
            const [trackToDelete, setTrackToDelete] = useState(null);
            const [settingsTrackId, setSettingsTrackId] = useState(null); 
            const [lastSavedPath, setLastSavedPath] = useState(null);
            
            // Renaming State
            const [renamingTrackId, setRenamingTrackId] = useState(null);

            const [barCount, setBarCount] = useState(1);
            const [viewedPage, setViewedPage] = useState(0);
            const [clipboard, setClipboard] = useState(null);

            // SELECTION STATE
            const [selection, setSelection] = useState(null); 
            const [isSelecting, setIsSelecting] = useState(false);

            // DRAG NOTE STATE
            const [dragState, setDragState] = useState(null); 
            
            const totalSteps = barCount * STEPS_PER_BAR;
            const [resizing, setResizing] = useState(null); 

            const audioRef = useRef(null);
            const timerRef = useRef(null);
            const stepRef = useRef(0);
            const nextNoteTimeRef = useRef(0);
            const tracksRef = useRef(tracks);
            const bpmRef = useRef(bpm);
            const totalStepsRef = useRef(totalSteps);
            const scrollContainerRef = useRef(null);

            useEffect(() => { tracksRef.current = tracks; }, [tracks]);
            useEffect(() => { bpmRef.current = bpm; }, [bpm]);
            useEffect(() => { totalStepsRef.current = totalSteps; }, [totalSteps]);

            useEffect(() => {
                audioRef.current = new RetroSynth();
                return () => { if (timerRef.current) cancelAnimationFrame(timerRef.current); };
            }, []);

            useEffect(() => {
                const el = scrollContainerRef.current;
                if (!el) return;
                const handleScroll = () => {
                    const width = el.clientWidth;
                    if (width > 0) {
                        const newPage = Math.round(el.scrollLeft / width);
                        if (newPage !== viewedPage) setViewedPage(newPage);
                    }
                };
                el.addEventListener('scroll', handleScroll);
                return () => el.removeEventListener('scroll', handleScroll);
            }, [viewedPage]);

            // GLOBAL MOUSE EVENTS
            useEffect(() => {
                const handleGlobalMouseUp = () => { 
                    if (resizing) setResizing(null);
                    if (isSelecting) {
                        setIsSelecting(false);
                        // Clear visual selection if start == end (just a click with shift)
                        if (selection && selection.startStep === selection.endStep && selection.startRow === selection.endRow) {
                            setSelection(null);
                        }
                    }
                    if (dragState) {
                        // COMMIT MOVE
                        if (dragState.isDragging) {
                            setTracks(prev => prev.map(t => {
                                if (t.id !== dragState.trackId) return t;
                                const newNotes = { ...t.notes };
                                dragState.originNotes.forEach(n => {
                                delete newNotes[n.step];
                                });
                                dragState.originNotes.forEach(n => {
                                    const newStep = n.step + dragState.deltaStep;
                                    const newRow = n.row + dragState.deltaRow;
                                    const maxRow = t.type === 'drum' ? DRUM_MAP.length - 1 : ORDERED_NOTES.length - 1;
                                    if (newStep >= 0 && newStep < totalSteps && newRow >= 0 && newRow <= maxRow) {
                                        const noteName = t.type === 'drum' ? DRUM_MAP[newRow] : ORDERED_NOTES[newRow];
                                        newNotes[newStep] = { note: noteName, length: n.length };
                                    }
                                });
                                return { ...t, notes: newNotes };
                            }));
                        } else {
                            if (dragState.originNotes.length === 1) {
                                const n = dragState.originNotes[0];
                                toggleNote(n.step, n.noteVal);
                            }
                        }
                        setDragState(null);
                    }
                };

                const handleGlobalMouseMove = (e) => {
                    if (resizing) {
                        const { trackId, stepIndex, startX, startLength } = resizing;
                        const pixelDelta = e.clientX - startX;
                        const stepDelta = Math.round(pixelDelta / 40); 
                        const newLen = Math.max(1, Math.min(totalSteps - stepIndex, startLength + stepDelta));
                        setTracks(prev => prev.map(t => {
                        if (t.id !== trackId) return t;
                        const newNotes = { ...t.notes };
                        if (newNotes[stepIndex]) newNotes[stepIndex] = { ...newNotes[stepIndex], length: newLen };
                        return { ...t, notes: newNotes };
                        }));
                    }

                    if (dragState) {
                        const pixelX = e.clientX - dragState.startX;
                        const pixelY = e.clientY - dragState.startY;
                        
                        if (!dragState.isDragging && (Math.abs(pixelX) > 5 || Math.abs(pixelY) > 5)) {
                            setDragState(prev => ({ ...prev, isDragging: true }));
                        }

                        if (dragState.isDragging || Math.abs(pixelX) > 5 || Math.abs(pixelY) > 5) {
                            const stepDelta = Math.round(pixelX / 40);
                            const rowDelta = Math.round(pixelY / 32);
                            setDragState(prev => ({ ...prev, isDragging: true, deltaStep: stepDelta, deltaRow: rowDelta }));
                        }
                    }
                };

                window.addEventListener('mouseup', handleGlobalMouseUp);
                window.addEventListener('mousemove', handleGlobalMouseMove);
                return () => {
                    window.removeEventListener('mouseup', handleGlobalMouseUp);
                    window.removeEventListener('mousemove', handleGlobalMouseMove);
                };
            }, [resizing, totalSteps, isSelecting, selection, dragState]);

            const isCellSelected = (step, row) => {
                if (!selection) return false;
                const minStep = Math.min(selection.startStep, selection.endStep);
                const maxStep = Math.max(selection.startStep, selection.endStep);
                const minRow = Math.min(selection.startRow, selection.endRow);
                const maxRow = Math.max(selection.startRow, selection.endRow);
                return step >= minStep && step <= maxStep && row >= minRow && row <= maxRow;
            };

            const handleCellMouseDown = (e, stepIndex, rowIndex) => {
                if (e.shiftKey) {
                    e.preventDefault();
                    setIsSelecting(true);
                    setSelection({ startStep: stepIndex, startRow: rowIndex, endStep: stepIndex, endRow: rowIndex });
                } else {
                    const track = tracks.find(t => t.id === selectedTrackId);
                    const noteVal = track.type === 'drum' ? DRUM_MAP[rowIndex] : ORDERED_NOTES[rowIndex];
                    const existingNote = track.notes[stepIndex];

                    if (existingNote && existingNote.note === noteVal) {
                        e.preventDefault();
                        
                        let movingNotes = [];
                        if (isCellSelected(stepIndex, rowIndex)) {
                            // Clicking inside active selection -> Drag group
                            Object.keys(track.notes).forEach(sStr => {
                                const s = parseInt(sStr);
                                const n = track.notes[s];
                                const r = track.type === 'drum' ? DRUM_MAP.indexOf(n.note) : ORDERED_NOTES.indexOf(n.note);
                                if (isCellSelected(s, r)) {
                                    movingNotes.push({ step: s, row: r, length: n.length, noteVal: n.note });
                                }
                            });
                        } else {
                            // Clicked an unselected note
                            // If selection exists, just deselect and return
                            if (selection) {
                                setSelection(null);
                                return;
                            }
                            // Otherwise prepare single note drag
                            movingNotes.push({ step: stepIndex, row: rowIndex, length: existingNote.length, noteVal: existingNote.note });
                        }
                        setDragState({ startX: e.clientX, startY: e.clientY, trackId: track.id, originNotes: movingNotes, deltaStep: 0, deltaRow: 0, isDragging: false });
                    } else {
                        // Clicked empty cell
                        if (selection && !e.shiftKey) {
                            // Just clear selection if it exists
                            setSelection(null);
                            return; 
                        }
                        toggleNote(stepIndex, noteVal);
                    }
                }
            };

            const handleCellMouseEnter = (stepIndex, rowIndex) => {
                if (isSelecting) {
                    setSelection(prev => ({ ...prev, endStep: stepIndex, endRow: rowIndex }));
                }
            };

            const toggleNote = (step, noteValue) => {
                setTracks(prev => prev.map(t => {
                    if (t.id !== selectedTrackId) return t;
                    const newNotes = { ...t.notes };
                    if (newNotes[step] && newNotes[step].note === noteValue) delete newNotes[step];
                    else newNotes[step] = { note: noteValue, length: 1 };
                    return { ...t, notes: newNotes };
                }));
            };

            const handlePlayToggle = () => {
                if (!audioRef.current) return;
                audioRef.current.resume();
                if (isPlaying) { setIsPlaying(false); if (timerRef.current) cancelAnimationFrame(timerRef.current); } 
                else { setIsPlaying(true); stepRef.current = 0; setCurrentStep(0); nextNoteTimeRef.current = audioRef.current.ctx.currentTime + 0.1; scheduler(); }
            };
            const scheduler = () => {
                const secondsPerBeat = 60.0 / bpmRef.current;
                const stepDuration = secondsPerBeat / 4; 
                const lookahead = 0.1; 
                const maxSteps = totalStepsRef.current; 
                while (nextNoteTimeRef.current < audioRef.current.ctx.currentTime + lookahead) {
                    scheduleNote(stepRef.current, nextNoteTimeRef.current, stepDuration);
                    nextNoteTimeRef.current += stepDuration;
                    stepRef.current = (stepRef.current + 1) % maxSteps;
                }
                timerRef.current = requestAnimationFrame(scheduler);
            };
            const scheduleNote = (step, time, stepDuration) => {
                if (step < totalStepsRef.current) requestAnimationFrame(() => setCurrentStep(step));
                tracksRef.current.forEach(track => {
                    const noteData = track.notes[step];
                    if (noteData && !track.muted) {
                        const params = track.params || getDefaultParams();
                        if (track.type === 'drum') {
                            if (noteData.note === 'Kick') audioRef.current.playDrum('kick', time, track.volume);
                            if (noteData.note === 'Snare') audioRef.current.playDrum('snare', time, track.volume);
                            if (noteData.note === 'HiHat') audioRef.current.playDrum('hihat', time, track.volume);
                        } else {
                            const freq = NOTE_FREQS[noteData.note];
                            if (freq) {
                                const duration = (noteData.length || 1) * stepDuration;
                                audioRef.current.playTone(freq, track.type, time, duration, track.volume, params);
                            }
                        }
                    }
                });
            };
            
            const exportWav = async () => {
                setIsExporting(true);
                try {
                    const secondsPerBeat = 60.0 / bpm;
                    const stepDuration = secondsPerBeat / 4;
                    const totalDuration = stepDuration * totalSteps;
                    const offlineCtx = new window.OfflineAudioContext(1, 44100 * totalDuration, 44100);
                    const offlineSynth = new RetroSynth(offlineCtx);
                    
                    for (let step = 0; step < totalSteps; step++) {
                        const time = step * stepDuration;
                        tracks.forEach(track => {
                            const noteData = track.notes[step];
                            if (noteData && !track.muted) {
                                const params = track.params || getDefaultParams();
                                if (track.type === 'drum') {
                                    if (noteData.note === 'Kick') offlineSynth.playDrum('kick', time, track.volume);
                                    if (noteData.note === 'Snare') offlineSynth.playDrum('snare', time, track.volume);
                                    if (noteData.note === 'HiHat') offlineSynth.playDrum('hihat', time, track.volume);
                                } else {
                                    const freq = NOTE_FREQS[noteData.note];
                                    if (freq) {
                                        const duration = (noteData.length || 1) * stepDuration;
                                        offlineSynth.playTone(freq, track.type, time, duration, track.volume, params);
                                    }
                                }
                            }
                        });
                    }
                    
                    const renderedBuffer = await offlineCtx.startRendering();
                    const wavBlob = bufferToWave(renderedBuffer, totalDuration * 44100);
                    
                    // Handle Save (Tauri or Browser)
                    if (isTauri) {
                        const savedPath = await saveFileTauri(`retro-track-${Date.now()}.wav`, wavBlob, 'wav');
                        if (savedPath) setLastSavedPath(savedPath);
                    } else {
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a'); a.href = url; a.download = `retro-track-${Date.now()}.wav`; a.click();
                    }
                } catch(e) { console.error(e); alert("Export failed."); } finally { setIsExporting(false); }
            };

            const exportMidi = async () => {
                try {
                    const midiWriter = new SimpleMidiWriter(bpm, "Bunny Retro Song");
                    
                    tracks.forEach(track => {
                        if (Object.keys(track.notes).length > 0) {
                            midiWriter.addTrack(track.notes, track.type === 'drum', track.name);
                        }
                    });

                    const midiData = midiWriter.build();
                    const blob = new Blob([midiData], { type: "audio/midi" });
                    
                    if (isTauri) {
                        const savedPath = await saveFileTauri(`retro-song-${Date.now()}.mid`, blob, 'mid'); 
                        if (savedPath) setLastSavedPath(savedPath);
                    } else {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `retro-song-${Date.now()}.mid`;
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                } catch (e) {
                    console.error("MIDI Export Error:", e);
                    alert("Failed to export MIDI.");
                }
            };

            const saveProject = async () => {
                const projectData = JSON.stringify({ tracks, bpm, barCount });
                
                if (isTauri) {
                    const savedPath = await saveFileTauri('retro-song.json', projectData, 'json');
                    if (savedPath) setLastSavedPath(savedPath);
                } else {
                    const blob = new Blob([projectData], { type: 'application/json' });
                    const a = document.createElement('a'); 
                    a.href = URL.createObjectURL(blob); 
                    a.download = 'retro-song.json'; 
                    a.click();
                }
            };

            // --- RENAMING LOGIC ---
            const updateTrackName = (id, newName) => {
                setTracks(prev => prev.map(t => t.id === id ? { ...t, name: newName } : t));
                setRenamingTrackId(null);
            };

            const startResize = (e, trackId, stepIndex) => { e.stopPropagation(); const track = tracks.find(t => t.id === trackId); const note = track.notes[stepIndex]; if (note) setResizing({ trackId, stepIndex, startX: e.clientX, startLength: note.length || 1 }); };
            const updateTrackVolume = (id, val) => setTracks(prev => prev.map(t => t.id === id ? { ...t, volume: parseFloat(val) } : t));
            const toggleTrackMute = (id) => setTracks(prev => prev.map(t => t.id === id ? { ...t, muted: !t.muted } : t));
            const addNewTrack = (type) => { const newId = Math.max(0, ...tracks.map(t => t.id)) + 1; const newColor = AVAILABLE_COLORS[(newId - 1) % AVAILABLE_COLORS.length]; let name = "New Track"; if (type === 'square') name = `Lead ${newId} (Sqr)`; if (type === 'sawtooth') name = `Lead ${newId} (Saw)`; if (type === 'triangle') name = `Bass ${newId} (Tri)`; if (type === 'drum') name = `Drums ${newId}`; setTracks([...tracks, { id: newId, name: name, type: type, volume: 0.6, color: newColor, notes: {}, params: getDefaultParams() }]); setSelectedTrackId(newId); setIsAddTrackOpen(false); };
            const initiateDeleteTrack = (id) => { if (tracks.length > 1) setTrackToDelete(tracks.find(t => t.id === id)); };
            const confirmDeleteTrack = () => { if (trackToDelete) { const newTracks = tracks.filter(t => t.id !== trackToDelete.id); setTracks(newTracks); if (selectedTrackId === trackToDelete.id) setSelectedTrackId(newTracks[0].id); setTrackToDelete(null); } };
            const confirmClear = () => { if (clearConfirmType === 'track') setTracks(prev => prev.map(t => t.id === selectedTrackId ? {...t, notes: {}} : t)); else if (clearConfirmType === 'all') setTracks(prev => prev.map(t => ({...t, notes: {}}))); setClearConfirmType(null); };
            const updateTrackParam = (trackId, param, value) => { setTracks(prev => prev.map(t => t.id !== trackId ? t : { ...t, params: { ...t.params, [param]: parseFloat(value) } })); };
            const randomizeTrackSettings = (trackId) => { const randomParams = { attack: 0.001 + Math.random() * 0.1, decay: 0.05 + Math.random() * 0.3, sustain: Math.random(), release: 0.05 + Math.random() * 0.5, timbre: Math.random() }; setTracks(prev => prev.map(t => t.id !== trackId ? t : { ...t, params: randomParams })); };
            const handleCopy = () => { if (selection) { const minStep = Math.min(selection.startStep, selection.endStep); const maxStep = Math.max(selection.startStep, selection.endStep); const notesToCopy = {}; Object.keys(selectedTrack.notes).forEach(stepStr => { const step = parseInt(stepStr); if (step >= minStep && step <= maxStep) { const noteVal = selectedTrack.notes[step].note; const noteIdx = selectedTrack.type === 'drum' ? DRUM_MAP.indexOf(noteVal) : ORDERED_NOTES.indexOf(noteVal); const minRow = Math.min(selection.startRow, selection.endRow); const maxRow = Math.max(selection.startRow, selection.endRow); if (noteIdx >= minRow && noteIdx <= maxRow) { notesToCopy[step - minStep] = selectedTrack.notes[step]; } } }); setClipboard({ type: 'selection', data: notesToCopy }); } else { const startStep = viewedPage * STEPS_PER_BAR; const endStep = startStep + STEPS_PER_BAR; const clipboardData = {}; tracks.forEach(track => { const trackNotes = {}; Object.keys(track.notes).forEach(stepStr => { const step = parseInt(stepStr); if (step >= startStep && step < endStep) trackNotes[step - startStep] = track.notes[step]; }); clipboardData[track.id] = trackNotes; }); setClipboard({ type: 'page', data: clipboardData }); } };
            const handlePaste = () => { if (!clipboard) return; if (clipboard.type === 'selection') { const targetStart = selection ? Math.min(selection.startStep, selection.endStep) : Math.floor(currentStep); setTracks(prev => prev.map(t => { if (t.id !== selectedTrackId) return t; const newNotes = { ...t.notes }; Object.keys(clipboard.data).forEach(relStepStr => { const relStep = parseInt(relStepStr); newNotes[targetStart + relStep] = clipboard.data[relStepStr]; }); return { ...t, notes: newNotes }; })); } else if (clipboard.type === 'page') { const startStep = viewedPage * STEPS_PER_BAR; const endStep = startStep + STEPS_PER_BAR; setTracks(prev => prev.map(track => { const sourceNotes = clipboard.data[track.id]; if (!sourceNotes) return track; const newNotes = { ...track.notes }; for (let i = startStep; i < endStep; i++) delete newNotes[i]; Object.keys(sourceNotes).forEach(relStepStr => { const relStep = parseInt(relStepStr); newNotes[startStep + relStep] = sourceNotes[relStep]; }); return { ...track, notes: newNotes }; })); } };
            const applyTemplate = (templateNotes) => { setTracks(prev => prev.map(t => t.id === selectedTrackId ? { ...t, notes: { ...templateNotes } } : t)); setShowTemplates(false); };
            const generateRandomMelody = () => { const scale = ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5"]; const newNotes = {}; for (let i = 0; i < totalSteps; i += 2) if (Math.random() > 0.3) newNotes[i] = { note: scale[Math.floor(Math.random() * scale.length)], length: 1 }; applyTemplate(newNotes); };
            
            const loadProject = (e) => { const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); if (data.tracks) setTracks(data.tracks.map(t => ({...t, params: t.params || getDefaultParams()}))); if (data.bpm) setBpm(data.bpm); if (data.barCount) setBarCount(data.barCount); } catch (err) {} }; if(e.target.files[0]) reader.readAsText(e.target.files[0]); };
            const scrollToPage = (i) => { if (scrollContainerRef.current) { const width = scrollContainerRef.current.clientWidth; scrollContainerRef.current.scrollTo({ left: i * width, behavior: 'smooth' }); setViewedPage(i); } };
            const changeBarCount = (d) => setBarCount(p => Math.max(1, Math.min(8, p + d)));
            const getAvailableTemplates = () => { const track = tracks.find(t => t.id === selectedTrackId); if (!track) return []; if (track.type === 'drum') return PATTERN_TEMPLATES.drum; if (track.type === 'triangle') return PATTERN_TEMPLATES.bass; return PATTERN_TEMPLATES.melody; };

            const selectedTrack = tracks.find(t => t.id === selectedTrackId);
            const settingsTrack = tracks.find(t => t.id === settingsTrackId);
            const ParamSlider = ({ label, value, min, max, step, onChange, suffix = "" }) => ( <div className="mb-3"><div className="flex justify-between mb-1 text-xs text-gba-text-muted"><span>{label}</span><span>{value && value.toFixed(2)}{suffix}</span></div><input type="range" min={min} max={max} step={step} value={value || 0} onChange={(e) => onChange(e.target.value)} className="w-full h-1 bg-gba-bg-light rounded-none appearance-none cursor-pointer accent-gba-blue border border-gba-border-light" /></div> );

            return (
                <div className={`flex flex-col h-screen bg-gba-bg-dark text-gba-text font-sans select-none overflow-hidden ${resizing ? 'cursor-col-resize' : ''}`} onClick={() => setShowTemplates(false)}>
                {/* ... (Modals) ... */}
                {settingsTrack && ( <div className="absolute inset-0 bg-black/70 z-50 flex items-center justify-center backdrop-blur-sm" onClick={() => setSettingsTrackId(null)}> <div className="bg-gba-bg-light border-2 border-gba-border p-5 shadow-2xl w-72" onClick={(e) => e.stopPropagation()}> <div className="flex items-center justify-between mb-4 border-b-2 border-gba-border pb-2"> <div className="flex items-center space-x-2"> <div className={`w-3 h-3 border border-black ${settingsTrack.color}`}></div> <h3 className="text-sm font-bold text-gba-text">{settingsTrack.name} Settings</h3> </div> <button onClick={() => setSettingsTrackId(null)}><X size={16} className="text-gba-text-muted hover:text-gba-text" /></button> </div> <div className="space-y-4"> <div className="bg-gba-bg-med p-3 border border-gba-border"> <div className="text-[10px] font-bold text-gba-text-muted uppercase mb-2 flex items-center"><Sliders size={10} className="mr-1"/> Envelope (ADSR)</div> <ParamSlider label="Attack" value={settingsTrack.params?.attack} min="0.001" max="1" step="0.01" onChange={(v) => updateTrackParam(settingsTrack.id, 'attack', v)} suffix="s" /> <ParamSlider label="Decay" value={settingsTrack.params?.decay} min="0.01" max="1" step="0.01" onChange={(v) => updateTrackParam(settingsTrack.id, 'decay', v)} suffix="s" /> <ParamSlider label="Sustain" value={settingsTrack.params?.sustain} min="0" max="1" step="0.01" onChange={(v) => updateTrackParam(settingsTrack.id, 'sustain', v)} /> <ParamSlider label="Release" value={settingsTrack.params?.release} min="0.01" max="2" step="0.01" onChange={(v) => updateTrackParam(settingsTrack.id, 'release', v)} suffix="s" /> </div> <div className="bg-gba-bg-med p-3 border border-gba-border"> <div className="text-[10px] font-bold text-gba-text-muted uppercase mb-2 flex items-center"><Wand2 size={10} className="mr-1"/> Timbre</div> <ParamSlider label="Tone / Filter" value={settingsTrack.params?.timbre} min="0" max="1" step="0.01" onChange={(v) => updateTrackParam(settingsTrack.id, 'timbre', v)} /> </div> <button onClick={() => randomizeTrackSettings(settingsTrack.id)} className="w-full py-2 bg-gba-btn hover:bg-gba-yellow text-gba-text hover:text-gba-bg-dark border-2 border-gba-border transition-colors flex items-center justify-center text-xs font-bold retro-btn" > <Dices size={14} className="mr-2" /> Randomize Sound </button> </div> </div> </div> )}
                {clearConfirmType && ( <div className="absolute inset-0 bg-black/70 z-50 flex items-center justify-center backdrop-blur-sm" onClick={() => setClearConfirmType(null)}> <div className="bg-gba-bg-light border-2 border-gba-border p-6 shadow-2xl max-w-sm w-full mx-4" onClick={(e) => e.stopPropagation()}> <div className="flex items-center space-x-3 mb-4 text-gba-red-light"> <AlertTriangle size={32} /> <h3 className="text-xl font-bold text-gba-text">{clearConfirmType === 'all' ? 'Reset Project?' : 'Clear Pattern?'}</h3> </div> <p className="text-gba-text-muted mb-6 leading-relaxed"> {clearConfirmType === 'all' ? <span className="text-gba-red-light">Warning: This will delete everything.</span> : <>Clear all notes from <span className="text-gba-text">{selectedTrack?.name}</span>?</>} </p> <div className="flex justify-end space-x-3"> <button onClick={() => setClearConfirmType(null)} className="px-4 py-2 text-gba-text-muted hover:bg-gba-btn border-2 border-gba-border retro-btn">Cancel</button> <button onClick={confirmClear} className="px-4 py-2 bg-gba-red hover:bg-gba-red-light text-gba-text border-2 border-gba-border retro-btn">Confirm</button> </div> </div> </div> )}
                {trackToDelete && ( <div className="absolute inset-0 bg-black/70 z-50 flex items-center justify-center backdrop-blur-sm" onClick={() => setTrackToDelete(null)}> <div className="bg-gba-bg-light border-2 border-gba-border p-6 shadow-2xl max-w-sm w-full mx-4" onClick={(e) => e.stopPropagation()}> <div className="flex items-center space-x-3 mb-4 text-gba-red-light"> <Trash2 size={32} /> <h3 className="text-xl font-bold text-gba-text">Delete Track?</h3> </div> <p className="text-gba-text-muted mb-6 leading-relaxed">Delete <span className="text-gba-text font-semibold">{trackToDelete.name}</span>?</p> <div className="flex justify-end space-x-3"> <button onClick={() => setTrackToDelete(null)} className="px-4 py-2 text-gba-text-muted hover:bg-gba-btn border-2 border-gba-border retro-btn">Cancel</button> <button onClick={confirmDeleteTrack} className="px-4 py-2 bg-gba-red hover:bg-gba-red-light text-gba-text border-2 border-gba-border retro-btn">Delete</button> </div> </div> </div> )}
                {isAddTrackOpen && ( <div className="absolute inset-0 bg-black/70 z-50 flex items-center justify-center backdrop-blur-sm" onClick={() => setIsAddTrackOpen(false)}> <div className="bg-gba-bg-light border-2 border-gba-border p-6 shadow-2xl max-w-sm w-full mx-4" onClick={(e) => e.stopPropagation()}> <h3 className="text-lg font-bold text-gba-text mb-4">Add New Track</h3> <div className="grid grid-cols-2 gap-3"> {['square', 'sawtooth', 'triangle', 'drum'].map(t => ( <button key={t} onClick={() => addNewTrack(t)} className="p-4 bg-gba-btn hover:bg-gba-blue hover:text-gba-bg-dark border-2 border-gba-border transition-colors flex flex-col items-center capitalize retro-btn"> <span className="text-sm font-semibold">{t}</span> </button> ))} </div> <button onClick={() => setIsAddTrackOpen(false)} className="mt-4 w-full py-2 text-gba-text-muted hover:text-gba-text border-2 border-gba-border retro-btn">Cancel</button> </div> </div> )}

                <div className="bg-gba-bg-light border-b-2 border-gba-border flex flex-col shadow-lg z-10 shrink-0">
                    {/* Top Row: Logo */}
                    <div className="h-12 flex items-center justify-start px-6 border-b border-gba-border bg-gba-bg-med">
                        <div className="flex items-center space-x-2">
                            <Music className="w-6 h-6 text-gba-purple" />
                            <h1 className="text-xl font-bold tracking-tighter text-gba-text">BUNNY <span className="text-gba-blue">RETRO STUDIO</span></h1>
                        </div>
                    </div>

                    {/* Bottom Row: Controls */}
                    <div className="h-14 flex items-center justify-between px-6">
                        {/* Left: Transport */}
                        <div className="flex items-center bg-gba-bg-med border-2 border-gba-border p-1">
                            <button onClick={handlePlayToggle} className={`p-2 retro-btn ${isPlaying ? 'bg-gba-red text-gba-text border-gba-border' : 'bg-gba-green text-gba-text border-gba-border hover:bg-gba-green-light'}`} title="Play/Pause"> {isPlaying ? <Pause size={20} fill="currentColor" /> : <Play size={20} fill="currentColor" />} </button>
                            <div className="px-4 flex items-center space-x-2 border-l-2 border-gba-border ml-2"> 
                                <span className="text-xs text-gba-text-muted uppercase font-bold">BPM</span> 
                                <input type="number" value={bpm} onChange={(e) => setBpm(Number(e.target.value))} className="w-16 bg-gba-bg-dark border-2 border-gba-border rounded-none px-2 py-1 text-center focus:outline-none focus:border-gba-blue" /> 
                            </div>
                            <div className="px-4 flex items-center space-x-2 border-l-2 border-gba-border ml-2"> 
                                <span className="text-xs text-gba-text-muted uppercase font-bold">BARS</span> 
                                <div className="flex items-center bg-gba-bg-dark border-2 border-gba-border"> 
                                    <button onClick={() => changeBarCount(-1)} className="px-2 hover:text-gba-blue retro-btn border-0 border-r-2 border-gba-border bg-gba-btn">-</button> 
                                    <span className="w-8 text-center text-sm font-mono">{barCount}</span> 
                                    <button onClick={() => changeBarCount(1)} className="px-2 hover:text-gba-blue retro-btn border-0 border-l-2 border-gba-border bg-gba-btn">+</button> 
                                </div> 
                            </div>
                        </div>

                        {/* Right: Actions */}
                        <div className="flex items-center space-x-3">
                            <div className="relative">
                                <button onClick={(e) => { e.stopPropagation(); setShowTemplates(!showTemplates); }} className="px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn text-gba-text-muted hover:text-gba-yellow hover:bg-gba-btn-hover border-2 border-gba-border">
                                    <Wand2 size={16} />
                                    <span className="text-xs font-bold">Patterns</span>
                                </button>
                                {showTemplates && ( <div className="absolute right-0 top-full mt-2 w-48 bg-gba-bg-light border-2 border-gba-border shadow-xl overflow-hidden z-50"> <div className="px-3 py-2 text-[10px] font-bold text-gba-text-muted uppercase tracking-wider border-b-2 border-gba-border">Patterns</div> {getAvailableTemplates().map((tmpl, idx) => <button key={idx} onClick={() => applyTemplate(tmpl.notes)} className="w-full text-left px-4 py-2 text-sm text-gba-text hover:bg-gba-bg-med font-mono border-b border-gba-border last:border-0">{tmpl.name}</button>)} {selectedTrack?.type !== 'drum' && <button onClick={generateRandomMelody} className="w-full text-left px-4 py-2 text-sm text-gba-yellow hover:bg-gba-bg-med border-t-2 border-gba-border font-mono"> Randomize</button>} </div> )} 
                            </div>
                            
                            <button onClick={() => setClearConfirmType('track')} className="px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn text-gba-text-muted hover:text-gba-red-light hover:bg-gba-btn-hover border-2 border-gba-border">
                                <Trash2 size={16} />
                                <span className="text-xs font-bold">Clear</span>
                            </button>
                            
                            <button onClick={() => setClearConfirmType('all')} className="px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn text-gba-text-muted hover:text-gba-red hover:bg-gba-btn-hover border-2 border-gba-border">
                                <FileWarning size={16} />
                                <span className="text-xs font-bold">Reset</span>
                            </button>
                            
                            <label className="px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn text-gba-text-muted hover:text-gba-blue hover:bg-gba-btn-hover border-2 border-gba-border cursor-pointer">
                                <Upload size={16} />
                                <span className="text-xs font-bold">Load</span>
                                <input type="file" className="hidden" onChange={loadProject} accept=".json" />
                            </label>
                            
                            <button onClick={saveProject} className="px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn text-gba-text-muted hover:text-gba-blue hover:bg-gba-btn-hover border-2 border-gba-border">
                                <Save size={16} />
                                <span className="text-xs font-bold">Save</span>
                            </button>
                            
                            <button onClick={exportMidi} className="px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn text-gba-text-muted hover:text-gba-purple hover:bg-gba-btn-hover border-2 border-gba-border" title="Export to MIDI">
                                <Music size={16} />
                                <span className="text-xs font-bold">MIDI</span>
                            </button>

                            <button onClick={exportWav} disabled={isExporting} className={`px-3 py-2 flex items-center gap-2 retro-btn bg-gba-btn border-2 border-gba-border ${isExporting ? 'text-gba-yellow animate-pulse' : 'text-gba-green hover:text-gba-green-light hover:bg-gba-btn-hover'}`} title="Export to WAV">
                                {isExporting ? "..." : <Download size={16} />}
                                <span className="text-xs font-bold">WAV</span>
                            </button>
                        </div>
                    </div>
                </div>

                {/* NOTIFICATION TOAST (Bottom) */}
                {lastSavedPath && (
                    <div className="absolute bottom-10 right-10 z-50 bg-gba-green border-2 border-gba-border text-gba-bg-dark px-4 py-3 shadow-[4px_4px_0px_0px_rgba(0,0,0,0.5)] flex items-center space-x-4 animate-bounce-in font-mono">
                        <div className="flex items-center space-x-2">
                            <CheckCircle size={20} className="text-gba-bg-dark" />
                            <span className="font-bold text-sm">FILE SAVED!</span>
                        </div>
                        <button 
                            onClick={() => openFileLocationTauri(lastSavedPath)}
                            className="flex items-center space-x-1 bg-gba-green-light hover:bg-white px-3 py-1 text-xs font-bold uppercase tracking-wide transition-colors border-2 border-gba-border retro-btn"
                        >
                            <FolderOpen size={14} />
                            <span>Open Folder</span>
                        </button>
                        <button 
                            onClick={() => setLastSavedPath(null)}
                            className="text-gba-bg-dark hover:text-white"
                        >
                            <X size={14} />
                        </button>
                    </div>
                )}

                <div className="flex flex-1 overflow-hidden border-t-2 border-gba-border">
                    <div className="w-64 bg-gba-bg-light border-r-2 border-gba-border flex flex-col z-20 shadow-xl shrink-0">
                    {/* Sidebar content same as before */}
                    <div className="p-3 text-xs font-bold text-gba-text-muted uppercase tracking-wider border-b-2 border-gba-border bg-gba-bg-med font-mono">Tracks</div>
                    <div className="flex-1 overflow-y-auto custom-scrollbar bg-gba-bg-light">
                        {tracks.map(track => (
                        <div key={track.id} onClick={() => setSelectedTrackId(track.id)} className={`p-3 border-b-2 border-gba-border cursor-pointer relative group transition-colors ${selectedTrackId === track.id ? 'bg-gba-bg-med' : 'hover:bg-gba-btn'}`}>
                            <div className="flex items-center justify-between mb-2">
                            <div className="flex items-center space-x-2"> <div className={`w-3 h-3 ${track.color} ${selectedTrackId === track.id ? 'animate-pulse' : ''} border border-black`}></div> 
                            
                            {/* --- RENAMING LOGIC HERE --- */}
                            {renamingTrackId === track.id ? (
                                <input 
                                    autoFocus
                                    defaultValue={track.name}
                                    onBlur={(e) => updateTrackName(track.id, e.target.value)}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') updateTrackName(track.id, e.currentTarget.value);
                                        if (e.key === 'Escape') setRenamingTrackId(null);
                                        e.stopPropagation(); // Prevent keyboard shortcuts
                                    }}
                                    onClick={(e) => e.stopPropagation()}
                                    className="bg-gba-bg-dark text-gba-text font-mono text-sm border-b border-gba-blue outline-none w-full"
                                />
                            ) : (
                                <span 
                                    className={`font-bold font-mono ${selectedTrackId === track.id ? 'text-gba-text' : 'text-gba-text-muted'}`}
                                    onDoubleClick={(e) => {
                                        e.stopPropagation();
                                        setRenamingTrackId(track.id);
                                    }}
                                    title="Double click to rename"
                                >
                                    {track.name}
                                </span>
                            )}

                            </div>
                            <div className="flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                {track.type !== 'drum' && ( <button onClick={(e) => { e.stopPropagation(); setSettingsTrackId(track.id); }} className="p-1 hover:text-gba-blue text-gba-text-muted transition-colors" title="Sound Settings"> <Settings2 size={14} /> </button> )}
                                {track.muted ? <span className="text-xs text-gba-red-light font-bold">MUTED</span> : <button onClick={(e) => { e.stopPropagation(); initiateDeleteTrack(track.id); }} className="p-1 hover:text-gba-red text-gba-text-muted transition-colors" title="Delete Track"> <X size={14} /> </button> }
                            </div>
                            </div>
                            <div className="flex items-center space-x-2"> <Volume2 size={14} className="text-gba-text-muted" /> <input type="range" min="0" max="1" step="0.05" value={track.volume} onClick={(e) => e.stopPropagation()} onChange={(e) => updateTrackVolume(track.id, e.target.value)} className="w-full h-1 bg-gba-bg-dark rounded-none appearance-none cursor-pointer accent-gba-blue border border-gba-border" /> </div>
                            <div className="mt-2 flex justify-end opacity-0 group-hover:opacity-100 transition-opacity"> <button onClick={(e) => { e.stopPropagation(); toggleTrackMute(track.id); }} className={`text-xs px-2 py-0.5 border-2 ${track.muted ? 'bg-gba-red-light text-gba-bg-dark border-gba-red' : 'bg-gba-btn text-gba-text-muted border-gba-border'} hover:brightness-110 font-mono retro-btn`}>{track.muted ? 'UNMUTE' : 'MUTE'}</button> </div>
                            {selectedTrackId === track.id && <div className="absolute left-0 top-0 bottom-0 w-1 bg-gba-blue"></div>}
                        </div>
                        ))}
                    </div>
                    <div className="p-3 border-t-2 border-gba-border bg-gba-bg-light">
                        <button onClick={() => setIsAddTrackOpen(true)} className="w-full py-2 bg-gba-btn hover:bg-gba-btn-hover border-2 border-gba-border text-gba-text flex items-center justify-center space-x-2 transition-all retro-btn"><Plus size={16} /><span className="text-sm font-bold font-mono">Add Track</span></button>
                    </div>
                    </div>

                    <div className="flex-1 flex flex-col bg-gba-bg-dark overflow-hidden relative">
                    <div ref={scrollContainerRef} className="flex-1 overflow-x-auto overflow-y-auto custom-scrollbar relative flex flex-col">
                        <div style={{ width: `${barCount * 100}%`, minWidth: '100%', display: 'flex', flexDirection: 'column', flex: 1 }}>
                            <div className="h-8 bg-gba-bg-light border-b-2 border-gba-border flex shrink-0 sticky top-0 z-30">
                            <div className="w-20 flex-shrink-0 bg-gba-bg-light border-r-2 border-gba-border sticky left-0 z-30"></div>
                            {Array.from({ length: totalSteps }).map((_, i) => (
                                <div key={i} className={`flex-1 border-r border-gba-border text-[10px] text-gba-text-muted flex items-center justify-center font-mono ${currentStep === i ? 'bg-gba-bg-med text-gba-text font-bold' : ''} ${(i % 16 === 0 && i !== 0) ? 'border-l-2 border-l-gba-border-light' : ''}`}>{i + 1}</div>
                            ))}
                            </div>
                            <div className="flex-1 pb-20 relative bg-gba-bg-dark" style={{backgroundImage: 'radial-gradient(#1e2536 1px, transparent 1px)', backgroundSize: '20px 20px'}}>
                            {selectedTrack?.type === 'drum' ? (
                                <div className="flex flex-col">
                                {DRUM_MAP.map((drumName, rowIndex) => (
                                    <div key={drumName} className="flex h-16 border-b border-gba-border">
                                    <div className="w-20 flex-shrink-0 bg-gba-bg-light border-r-2 border-gba-border flex items-center justify-end px-3 text-xs font-bold text-gba-text-muted sticky left-0 z-20 shadow-md font-mono border-b border-gba-border">{drumName}</div>
                                    <div className="flex-1 flex relative">
                                        {Array.from({ length: totalSteps }).map((_, stepIndex) => {
                                        const noteData = selectedTrack.notes[stepIndex];
                                        const isInDrag = dragState?.isDragging && dragState.trackId === selectedTrack.id && dragState.originNotes.some(n => n.step === stepIndex && n.row === rowIndex);
                                        
                                        let phantomNote = null;
                                        if (dragState?.isDragging && dragState.trackId === selectedTrack.id) {
                                            const draggedOrigin = dragState.originNotes.find(n => n.step + dragState.deltaStep === stepIndex && n.row + dragState.deltaRow === rowIndex);
                                            if (draggedOrigin) phantomNote = { length: draggedOrigin.length, note: drumName }; 
                                        }

                                        const noteToRender = phantomNote || (isInDrag ? null : noteData);
                                        const isActive = noteToRender && noteToRender.note === drumName;
                                        const isCurrent = currentStep >= stepIndex && currentStep < (stepIndex + (noteToRender?.length || 1));
                                        const isBarStart = stepIndex % 16 === 0 && stepIndex !== 0;
                                        const selected = isCellSelected(stepIndex, rowIndex);
                                        
                                        return (
                                            <div 
                                                key={stepIndex} 
                                                onMouseDown={(e) => handleCellMouseDown(e, stepIndex, rowIndex)}
                                                onMouseEnter={() => handleCellMouseEnter(stepIndex, rowIndex)}
                                                className={`flex-1 border-r border-gba-border cursor-pointer relative 
                                                    ${isBarStart ? 'border-l-2 border-l-gba-border-light' : ''} 
                                                    ${isCurrent ? 'bg-gba-bg-med/50' : ''}
                                                    ${selected && isSelecting ? 'bg-gba-blue/20' : ''}
                                                `}
                                            >
                                            {isActive && (
                                                <div 
                                                    className={`absolute inset-1 ${selectedTrack.color} z-10 border-2 border-black shadow-md
                                                        ${selected ? 'border-white ring-2 ring-white/50' : ''} 
                                                        ${phantomNote ? 'opacity-80 ring-2 ring-gba-yellow border-gba-yellow-light' : (isInDrag ? 'opacity-30' : 'opacity-100')}
                                                    `} 
                                                    style={{ width: `calc(${noteToRender.length * 100}% - 4px)` }}
                                                >
                                                    <div className="absolute right-0 top-0 bottom-0 w-3 cursor-col-resize hover:bg-white/30 border-l border-black/20" onMouseDown={(e) => startResize(e, selectedTrack.id, stepIndex)}></div>
                                                </div>
                                            )}
                                            </div>
                                        );
                                        })}
                                    </div>
                                    </div>
                                ))}
                                </div>
                            ) : (
                                <div className="flex flex-col">
                                {ORDERED_NOTES.map((note, rowIndex) => (
                                    <div key={note} className="flex h-8 border-b border-gba-border hover:bg-gba-bg-med/30">
                                    <div className="w-20 flex-shrink-0 bg-gba-bg-light border-r-2 border-gba-border flex items-center justify-end px-2 text-[10px] sticky left-0 z-20 shadow-md text-gba-text-muted font-mono border-b border-gba-border">{note}</div>
                                    <div className="flex-1 flex relative bg-transparent">
                                        {Array.from({ length: totalSteps }).map((_, stepIndex) => {
                                        const noteData = selectedTrack?.notes[stepIndex];
                                        const isInDrag = dragState?.isDragging && dragState.trackId === selectedTrack.id && dragState.originNotes.some(n => n.step === stepIndex && n.row === rowIndex);
                                        
                                        let phantomNote = null;
                                        if (dragState?.isDragging && dragState.trackId === selectedTrack.id) {
                                            const draggedOrigin = dragState.originNotes.find(n => n.step + dragState.deltaStep === stepIndex && n.row + dragState.deltaRow === rowIndex);
                                            if (draggedOrigin) phantomNote = { length: draggedOrigin.length, note: note };
                                        }

                                        const noteToRender = phantomNote || (isInDrag ? null : noteData);
                                        const isActive = noteToRender && noteToRender.note === note;
                                        const isCurrent = currentStep === stepIndex;
                                        const isBarStart = stepIndex % 16 === 0 && stepIndex !== 0;
                                        const selected = isCellSelected(stepIndex, rowIndex);

                                        return (
                                            <div 
                                                key={stepIndex} 
                                                onMouseDown={(e) => handleCellMouseDown(e, stepIndex, rowIndex)}
                                                onMouseEnter={() => handleCellMouseEnter(stepIndex, rowIndex)}
                                                className={`flex-1 border-r border-gba-border cursor-pointer relative 
                                                    ${isBarStart ? 'border-l-2 border-l-gba-border-light' : ''} 
                                                    ${isCurrent ? 'bg-gba-bg-med/30' : ''}
                                                    ${selected && isSelecting ? 'bg-gba-blue/20' : ''}
                                                `}
                                            >
                                            {isActive && (
                                                <div 
                                                    className={`absolute top-0.5 bottom-0.5 left-0.5 ${selectedTrack.color} bg-opacity-90 z-10 border border-black shadow-sm
                                                        ${selected ? 'border-2 border-white ring-2 ring-white/50' : ''}
                                                        ${phantomNote ? 'opacity-80 ring-2 ring-gba-yellow border-gba-yellow-light' : (isInDrag ? 'opacity-30' : 'opacity-100')}
                                                    `} 
                                                    style={{ width: `calc(${noteToRender.length * 100}% - 1px)` }}
                                                >
                                                    <div className="w-full h-full bg-white opacity-10 pointer-events-none"></div>
                                                    <div className="absolute right-0 top-0 bottom-0 w-2 cursor-col-resize hover:bg-white/50 border-l border-black/20" onMouseDown={(e) => startResize(e, selectedTrack.id, stepIndex)}></div>
                                                </div>
                                            )}
                                            </div>
                                        );
                                        })}
                                    </div>
                                    </div>
                                ))}
                                </div>
                            )}
                            <div className="absolute top-0 bottom-0 w-0.5 bg-gba-yellow opacity-80 pointer-events-none z-30 transition-all duration-75 ease-linear shadow-[0_0_10px_2px_rgba(242,212,73,0.5)]" style={{ left: `calc(5rem + (${currentStep} * ((100% - 5rem) / ${totalSteps})))` }}></div>
                            </div>
                        </div>
                    </div>
                    <div className="h-10 bg-gba-bg-light border-t-2 border-gba-border flex items-center justify-center space-x-2 z-20 shrink-0">
                        <span className="text-[10px] text-gba-text-muted font-bold uppercase mr-2 font-mono">Quick Nav:</span>
                        <button onClick={handleCopy} className="px-2 py-1 bg-gba-btn hover:bg-gba-blue border-2 border-gba-border rounded-none text-xs text-gba-text-muted hover:text-gba-bg-dark flex items-center space-x-1 transition-colors mr-2 font-mono retro-btn" title={selection ? "Copy Selected Notes" : "Copy Current Page"}> <ClipboardCopy size={12} /> <span>{selection ? "Copy Sel" : "Copy Page"}</span> </button>
                        {Array.from({ length: barCount }).map((_, i) => <button key={i} onClick={() => scrollToPage(i)} className={`px-3 py-1 border-2 text-xs font-mono transition-colors retro-btn ${viewedPage === i ? 'bg-gba-blue text-gba-bg-dark border-gba-border' : 'bg-gba-btn hover:bg-gba-btn-hover text-gba-text-muted border-gba-border'}`}>Page {i + 1}</button>)}
                        <button onClick={handlePaste} disabled={!clipboard} className={`px-2 py-1 border-2 rounded-none text-xs flex items-center space-x-1 transition-colors ml-2 font-mono retro-btn ${!clipboard ? 'bg-gba-bg-med text-gba-text-muted border-gba-border cursor-not-allowed' : 'bg-gba-btn hover:bg-gba-green text-gba-text-muted hover:text-gba-bg-dark border-gba-border'}`} title={!clipboard ? "Nothing copied" : (clipboard.type === 'selection' ? "Paste at Playhead" : "Paste to Current Page")}> <ClipboardPaste size={12} /> <span>Paste</span> </button>
                    </div>
                    </div>
                </div>
                <div className="h-6 bg-gba-bg-dark text-gba-text-muted text-[10px] flex items-center justify-between px-4 shrink-0 border-t-2 border-gba-border font-mono">
                    <span>BUNNY RETRO STUDIO v6.1  RENAME TRACKS ADDED</span>
                    <span>SPACE TO PLAY</span>
                </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<RetroMusicCreator />);
    </script>
</body>
</html>